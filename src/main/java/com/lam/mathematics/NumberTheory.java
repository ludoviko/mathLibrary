package com.lam.mathematics;

import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class NumberTheory {

	/**
	 * 
	 * Frequently Asked Questions How do you work out the sum of divisors?
	 * 
	 * Imagine you wish to work out the sum of divisors of the number 72. It
	 * would not take long to list the divisors, and then find their sum: 1 + 2
	 * + 3 + 4 + 6 + 8 + 9 + 12 + 18 + 24 + 36 + 72 = 195.
	 * 
	 * However, this method would become both tedious and difficult for large
	 * numbers like 145600. Fortunately, there is a simple and elegant method at
	 * hand.
	 * 
	 * Let σ(n) be the sum of divisors of the natural number, n.
	 * 
	 * For any prime, p: σ(p) = p + 1, as the only divisors would be 1 and p.
	 * 
	 * Consider pa: σ(pa) = 1 + p + p2 + ... + pa (1).
	 * 
	 * Multiplying by p: pσ(pa) = p + p2 + p3 + ... + pa + 1 (2).
	 * 
	 * Subtracting (1) from (2): pσ(pa)−σ(pa) = (p−1)σ(pa) = pa+1 − 1.
	 * 
	 * Hence σ(pa) = (pa+1 − 1)/(p − 1).
	 * 
	 * For example, σ(34)=(35−1)/(3−1) = 242/2 = 121, and checking: 1 + 3 + 9 +
	 * 27 + 81 = 121.
	 * 
	 * Although no proof is supplied here, the usefulness of the function, σ(n),
	 * is its multiplicativity, which means that σ(a×b×...)=σ(a)×σ(b)×..., where
	 * a, b, ..., are relatively prime.
	 * 
	 * Returning to example, we use the fact that σ(72) = σ(23×32). As 23 and 32
	 * are relatively prime, we can separately work out σ(23) = 24 − 1 = 15 and
	 * σ(32) = (33 − 1)/2 = 13. Therefore, σ(72) = 15×13 = 195.
	 * 
	 * 
	 * © mathschallenge.net
	 * 
	 */
	public static long sigma(int n) {
		long sigma = 1;
		long prime;
		long power;

		if (n == 1) {
			return 1;
		}

		Map<Long, Long> map = Factorize.exponentialPrimeFactorization(n);
		Set<Long> set = map.keySet();

		Iterator<Long> itera = set.iterator();

		while (itera.hasNext()) {
			prime = itera.next();
			power = map.get(prime);
			sigma *= (long) (Math.pow(prime, power + 1) - 1) / (prime - 1);
		}
		return sigma;
	}

	/**
	 * If the sum of proper divisors exceeds the number it is called abundant
	 * for example, 12: 1 + 2 + 3 + 4 + 6 = 16.
	 * 
	 * @param n
	 * @return boolean
	 * 
	 */
	public static boolean isAbundant(int n) {
		return (NumberTheory.sigma(n) > 2 * n);
	}

	/**
	 * If the sum of proper divisors are less than the number it is called
	 * deficient, for example, 14: 1 + 2 + 7 = 10.
	 * 
	 * @param n
	 * @return boolean
	 * 
	 * 
	 */
	public static boolean isDeficient(int n) {
		return (NumberTheory.sigma(n) < 2 * n);
	}

	/**
	 * If P is a perfect number, σ(P)=2P.
	 * 
	 * The first eight perfect numbers are 6, 28, 496, 8128, 33550336,
	 * 8589869056, 137438691328, 2305843008139952128.
	 * 
	 * 
	 * 
	 * @param n
	 * @return boolean
	 * 
	 * 
	 */
	public static boolean isPerfect(int n) {
		return (NumberTheory.sigma(n) == 2 * n);
	}

	/**
	 * 
	 * Triangular number
	 * 
	 * The sequence of triangle numbers is generated by adding the natural
	 * numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 =
	 * 28. The first ten terms would be:
	 * 
	 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
	 * 
	 * */

	public static int triangleNumber(int n) {
		int sum = 0;
		sum = (1 + n) * n / 2;
		return sum;
	}

	/**
	 * 
	 * Happy numbers:
	 * 
	 * Starting with any positive integer, replace the number by the sum of the
	 * squares of its digits, and repeat the process until the number either
	 * equals 1 (where it will stay), or it loops endlessly in a cycle which
	 * does not include 1. 
	 * 
	 * Those numbers for which this process ends in 1 are
	 * happy numbers, while those that do not end in 1 are unhappy numbers (or
	 * sad numbers).
	 * 
	 * 
	 * As a rule, the sad numbers contains the cicle:
	 * 
	 * 4->16->37->58->89->145->42->20->4->16->37->...
	 * 
	 * So if the number is 4 it is a sad number.
	 * 
	 */

	public static boolean isHappyNumber(long n) {
		long digit = 0;
		long sum = 0;
        
		while (n > 0) {
			digit = n % 10;
			n /= 10;
			sum += digit * digit;
		}

        if ( sum == 1 ) {
    		return true;
        } else if ( sum == 4 ) {
        	return false;
        } else {
        	return isHappyNumber(sum);
        }
	}

}
